# -*- coding: utf-8 -*-
"""Dataset_Household-Power-Consumption.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1gZ_RRoQa4fMTpf1zhwiphpBEGVVO03kJ

# Importação dos Dados
"""

import pandas as pd

df = dados = pd.read_csv("/content/household_power_consumption.txt", sep=';', low_memory=False)

"""## 1. Carregue o dataset e exiba as 10 primeiras linhas."""

dados.head(10)

"""## 2. Explique a diferênça entre as variáveis Global_active_power e Global_reactive_power."""

# Global_active_power e Global_reactive_power são ambas medidas de potência elétrica, mas representam aspectos diferentes:

# Global_active_power (Potência Ativa): Potência real consumida pela residência para realizar trabalho útil.
# É medida em quilowatts (kW) e é a potência que aciona eletrodomésticos, luzes e outros dispositivos para fazerem o seu trabalho.

# Global_reactive_power (Potência Reativa): Potência que não é usada para realizar trabalho, mas é necessária para manter os campos eletromagnéticos exigidos por certos tipos de equipamentos elétricos, como motores e transformadores.
# É medida em kilovolt-amperes reativos (kVAR). Embora não realize trabalho diretamente, é essencial para o funcionamento de muitos dispositivos e contribui para o fluxo total de potência no sistema.

"""## 3. Verifique se existem valores ausêntes no dataset. Quantifique-os."""

missing_values = dados.isnull().sum()
print("Missing values per column:")
print(missing_values)

"""## 4. Converta a coluna Date para o tipo de datetime e crie uma nova coluna com o dia da semana correspondente."""

dados['Date'] = pd.to_datetime(dados['Date'], format='%d/%m/%Y')
dados['Day_of_Week'] = dados['Date'].dt.day_name()
display(dados.head())

"""## 5. Filtre os registros do ano de 2007 e calcule a média de consumo diário de Global_active_power."""

dados['Global_active_power'] = pd.to_numeric(dados['Global_active_power'], errors='coerce')
dados_2007 = dados[dados['Date'].dt.year == 2007]
daily_average_power_2007 = dados_2007.groupby('Date')['Global_active_power'].mean()
print("Média de consumo diário de Global_active_power em 2007:")
print(daily_average_power_2007.head())

"""## 6. Gere um gráfico de linha mostrando a variação de Global_active_power em um único dia à sua escolha."""

df = dados
df['datetime'] = pd.to_datetime(df['Date'].astype(str) + ' ' + df['Time'], dayfirst=True)
df = df.set_index('datetime')
df = df.drop(['Date', 'Time'], axis=1)

for col in ['Global_active_power', 'Global_reactive_power', 'Voltage', 'Global_intensity', 'Sub_metering_1', 'Sub_metering_2', 'Sub_metering_3']:
    df[col] = pd.to_numeric(df[col], errors='coerce')

display(df.head())

import matplotlib.pyplot as plt

single_day_data = df.loc['2006-12-16']

plt.figure(figsize=(12, 6))
plt.plot(single_day_data.index, single_day_data['Global_active_power'])
plt.title('Global Active Power on 2006-12-16')
plt.xlabel('Time')
plt.ylabel('Global Active Power (kilowatts)')
plt.xticks(rotation=45)
plt.tight_layout()
plt.show()

"""## 7. Crie um histograma da variável Voltage. O que pode ser observado sobre sua distribuição?"""

df  = df.dropna()
df['Voltage'].hist()

#O histograma da variável 'Voltage' mostra a frequência com que diferentes valores de tensão ocorrem no dataset.
#Observa-se que a distribuição é aproximadamente simétrica e centrada em torno de um valor,
#indicando que a tensão na rede elétrica da residência se mantém relativamente estável na maior parte do tempo.
#A maior concentração de leituras de tensão se encontra entre aproximadamente 235 e 245 Volts.

"""## 8. Calcule o consumo médio por mês em todo o período disponível no dataset."""

df['month'] = df.index.month
df['year'] = df.index.year
monthly_avg_consumption = df.groupby(['year', 'month'])['Global_active_power'].mean()
display(monthly_avg_consumption)

"""## 9. Identifique o dia com maior consumo de energia ativa global (Global_active_power)."""

daily_consumption = df.resample('D')['Global_active_power'].sum()
day_with_highest_consumption = daily_consumption.idxmax()
max_consumption = daily_consumption.max()

print(f"O dia com o maior consumo de energia ativa global foi {day_with_highest_consumption.date()} com um total de {max_consumption:.2f}.")

"""## 10. Compare o consumo médio de energia ativa global em dias de semana versus finais de semana."""

df['weekday'] = df.index.dayofweek
df['is_weekend'] = df['weekday'].apply(lambda x: 'Weekend' if x >= 5 else 'Weekday')

weekly_avg_consumption = df.groupby('is_weekend')['Global_active_power'].mean()
display(weekly_avg_consumption)

"""## 11. Calcule a correlação entre as variáveis Global_active_power, Global_reactive_power, Voltage e Global_intensity.

"""

correlation_matrix = df[['Global_active_power', 'Global_reactive_power', 'Voltage', 'Global_intensity']].corr()
print("Matriz de Correlação:")
display(correlation_matrix)

"""## 12. Crie uma nova variável chamada Total_Sub_metering que some Sub_metering_1, Sub_metering_2 e Sub_metering_3.

"""

df['Total_Sub_metering'] = df['Sub_metering_1'] + df['Sub_metering_2'] + df['Sub_metering_3']
display(df.head())

"""## 13. Verifique se há algum mês em que Total_Sub_metering ultrapassa a média de Global_active_power."""

monthly_total_sub_metering = df.groupby(['year', 'month'])['Total_Sub_metering'].mean()
comparison = monthly_total_sub_metering > monthly_avg_consumption
print("\nMeses onde o consumo de Total_Sub_metering ultrapassa a média de Global_active_power:")
display(comparison[comparison].index.tolist())

"""## 14. Faça um gráfico de série temporal do Voltage para o ano de 2008."""

voltage_2008 = df[df.index.year == 2008]['Voltage']

plt.figure(figsize=(12, 6))
plt.plot(voltage_2008.index, voltage_2008)
plt.title('Variação de Voltage em 2008')
plt.xlabel('Tempo')
plt.ylabel('Voltage (Volts)')
plt.tight_layout()
plt.show()

"""## 15. Compare o consumo entre os meses de verão e inverno (no hemisfério norte)."""

summer_months = [6, 7, 8]
winter_months = [12, 1, 2]

summer_consumption = df[df.index.month.isin(summer_months)]['Global_active_power'].mean()
winter_consumption = df[df.index.month.isin(winter_months)]['Global_active_power'].mean()

print(f"Consumo médio de Global_active_power no verão (Hemisfério Norte): {summer_consumption:.2f}")
print(f"Consumo médio de Global_active_power no inverno (Hemisfério Norte): {winter_consumption:.2f}")

"""## 16. Aplique uma amostragem aleatória de 1% dos dados e verifique se a distribuição de Global_active_power é semelhante à da base completa.

"""

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

amostra = df.sample(frac=0.01, random_state=42)

plt.figure(figsize=(12, 6))

sns.kdeplot(df['Global_active_power'], label='Base completa', color='blue', linewidth=2)
sns.kdeplot

"""## 17. Utilize uma técnica de normalização (Min-Max Scaling) para padronizar as variáveis numéricas principais."""

if 'df' in locals() and df is not None and not df.empty:
    numerical_cols_df = df.select_dtypes(include='number')
    print("Colunas numéricas no DataFrame:")
    print(numerical_cols_df.columns.tolist())
else:
    print("DataFrame 'df' não encontrado ou está vazio. Não é possível identificar colunas numéricas.")

"""## 18. Aplique K-means para segmentar os dias em 3 grupos distintos de consumo elétrico. Interpret os resultados."""

import pandas as pd

try:
    df = pd.read_csv('/content/household_power_consumption.txt', sep=';', low_memory=False)
    print("DataFrame carregado com sucesso.")

    df.dropna(inplace=True)
    print(f"Formato após remover valores ausentes: {df.shape}")

    df['Global_active_power'] = pd.to_numeric(df['Global_active_power'], errors='coerce')
    df.dropna(subset=['Global_active_power'], inplace=True)
    print(f"Formato após converter 'Global_active_power' e remover NaNs: {df.shape}")

    display(df.head())
    display(df.info())

except FileNotFoundError:
    print("Erro: O arquivo não foi encontrado em /content/household_power_consumption.txt")
except Exception as e:
    print(f"Ocorreu um erro: {e}")

"""## 19. Realize uma decomposição de série temporal (tendência, sazonalidade e resíduo) para Global_active_power em um período de 6 meses"""

import pandas as pd

try:
    df = pd.read_csv('/content/household_power_consumption.txt', sep=';', low_memory=False)
    print("DataFrame carregado com sucesso.")

    df['DateTime'] = df['Date'].astype(str) + ' ' + df['Time'].astype(str)


    df['DateTime'] = pd.to_datetime(df['DateTime'])


    df.set_index('DateTime', inplace=True)


    df.dropna(inplace=True)
    print(f"Formato após remover valores ausentes: {df.shape}")


    df['Global_active_power'] = pd.to_numeric(df['Global_active_power'], errors='coerce')
    df.dropna(subset=['Global_active_power'], inplace=True)
    print(f"Formato após converter 'Global_active_power' e remover NaNs: {df.shape}")

    display(df.head())
    display(df.info())

except FileNotFoundError:
    print("Erro: O arquivo não foi encontrado em /content/household_power_consumption.txt")
except Exception as e:
    print(f"Ocorreu um erro: {e}")

"""## 20. Treine um modelo de regressão linear simples para prever Global_active_power a partir de Global_intensity. Avalie o erro do modelo

"""

import pandas as pd

try:
    df = pd.read_csv('/content/household_power_consumption.txt', sep=';', low_memory=False)
    print("DataFrame carregado com sucesso.")

    df.dropna(inplace=True)
    print(f"Formato após remover valores ausentes: {df.shape}")

    df['Global_active_power'] = pd.to_numeric(df['Global_active_power'], errors='coerce')
    df['Global_intensity'] = pd.to_numeric(df['Global_intensity'], errors='coerce')

    df.dropna(subset=['Global_active_power', 'Global_intensity'], inplace=True)
    print(f"Formato após converter colunas e remover NaNs: {df.shape}")

    display(df.head())
    display(df.info())

except FileNotFoundError:
    print("Erro: O arquivo não foi encontrado em /content/household_power_consumption.txt")
except Exception as e:
    print(f"Ocorreu um erro: {e}")

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

try:
    df = pd.read_csv('/content/household_power_consumption.txt', sep=';', low_memory=False)
    print("DataFrame carregado com sucesso.")

    df.dropna(inplace=True)
    print(f"Formato após remover valores ausentes: {df.shape}")

    df['Global_active_power'] = pd.to_numeric(df['Global_active_power'], errors='coerce')
    df.dropna(subset=['Global_active_power'], inplace=True)
    print(f"Formato após converter 'Global_active_power' e remover NaNs: {df.shape}")

    amostra = df.sample(frac=0.01, random_state=42)

    plt.figure(figsize=(12, 6))

    sns.kdeplot(df['Global_active_power'], label='Base completa', color='blue', linewidth=2)
    sns.kdeplot(amostra['Global_active_power'], label='Amostra (1%)', color='red', linewidth=2)

    plt.title('Distribuição de Global_active_power: Base completa vs. Amostra')
    plt.xlabel('Global_active_power')
    plt.ylabel('Densidade')
    plt.legend()
    plt.grid(True)
    plt.show()

except FileNotFoundError:
    print("Erro: O arquivo não foi encontrado em /content/household_power_consumption.txt")
except Exception as e:
    print(f"Ocorreu um erro: {e}")

"""## 21. Séries temporais por hora.

Converta Date e Time em índice datetime.

Reamostre os dados em intervalos de 1 hora, calculando a média de Global_active_power.

Identifique os horários de maior consumo médio ao longo do dia.

Observação: uma série temporal é um conjunto de dados registrados em ordem cronológica, útil para identificar padrões de comportamento ao longo do tempo.

"""

import pandas as pd
df['DateTime'] = pd.to_datetime(df['Date'] + ' ' + df['Time'])
df.set_index('DateTime', inplace=True)
df_hourly = df['Global_active_power'].resample('H').mean()

print("Média de consumo ativo global por hora:")
display(df_hourly.head())

hourly_avg_consumption = df_hourly.groupby(df_hourly.index.hour).mean()
highest_consumption_hour = hourly_avg_consumption.idxmax()

print(f"\nHoras com o maior consumo médio ao longo do dia:")
display(hourly_avg_consumption.sort_values(ascending=False).head())

"""## 22. Autocorrelação do consumo.
Use a série temporal de Global_active_power.

Calcule a autocorrelação em lags de 1h, 24h e 48h.

Pergunta: existem padrões repetidos diariamente?

"""

#22. Autocorrelação do consumo. Use a série temporal de Global_active_power. Calcule a autocorrelação em lags de 1h, 24h e 48h. Pergunta: existem padrões repetidos diariamente?
autocorr_1h = df_hourly.autocorr(lag=1)
autocorr_24h = df_hourly.autocorr(lag=24)
autocorr_48h = df_hourly.autocorr(lag=48)

print(f"Autocorrelation at 1 hour lag: {autocorr_1h:.2f}")
print(f"Autocorrelation at 24 hour lag: {autocorr_24h:.2f}")
print(f"Autocorrelation at 48 hour lag: {autocorr_48h:.2f}")

print("\nInterpretation:")
if autocorr_24h > 0.5:
    print("There is a strong positive autocorrelation at a 24-hour lag, indicating a strong daily pattern in Global_active_power consumption.")
elif autocorr_24h > 0:
    print("There is a positive autocorrelation at a 24-hour lag, suggesting some daily pattern in Global_active_power consumption.")
else:
    print("There is weak or no positive autocorrelation at a 24-hour lag, suggesting no strong daily pattern in Global_active_power consumption.")

"""## 23. Redução de dimensionalidade com PCA.
Selecione Global_active_power, Global_reactive_power, Voltage e Global_intensity.

Aplique PCA para reduzir para 2 componentes principais.

Analise a variância explicada por cada componente

"""

df_pca_cols = df[['Global_active_power', 'Global_reactive_power', 'Voltage', 'Global_intensity']]

print("Missing values before dropping:")
missing_values_pca = df_pca_cols.isnull().sum()
display(missing_values_pca)

df_pca_cols.dropna(inplace=True)

print("\nMissing values after dropping:")
missing_values_pca_after = df_pca_cols.isnull().sum()
display(missing_values_pca_after)

display(df_pca_cols.head())

"""## 24. Visualização de clusters no espaço PCA.
Combine os resultados do PCA com K-Means (3 clusters).

Plote os pontos resultantes e pinte cada grupo por cluster.

Pergunta: os grupos se separam de forma clara?

"""

from sklearn.preprocessing import StandardScaler

# Padronizar os dados
scaler = StandardScaler()
df_pca_scaled = scaler.fit_transform(df_pca_cols)

# Converter de volta para DataFrame para facilitar o manuseio
df_pca_scaled = pd.DataFrame(df_pca_scaled, columns=df_pca_cols.columns, index=df_pca_cols.index)

display(df_pca_scaled.head())

from sklearn.decomposition import PCA

# Aplicar PCA
pca = PCA(n_components=2)
df_pca_result = pca.fit_transform(df_pca_scaled)

# Converter os resultados de volta para um DataFrame
df_pca_result = pd.DataFrame(df_pca_result, columns=['Componente Principal 1', 'Componente Principal 2'], index=df_pca_scaled.index)

display(df_pca_result.head())

from sklearn.cluster import KMeans
import numpy as np

# Aplicar agrupamento K-Means
kmeans = KMeans(n_clusters=3, random_state=42, n_init=10)
df_pca_result['Cluster'] = kmeans.fit_predict(df_pca_result)

display(df_pca_result.head())

import matplotlib.pyplot as plt

# Visualizar os clusters no espaço PCA
plt.figure(figsize=(10, 7))
plt.scatter(df_pca_result['Componente Principal 1'], df_pca_result['Componente Principal 2'], c=df_pca_result['Cluster'], cmap='viridis', s=10)
plt.title('Clusters no Espaço PCA')
plt.xlabel('Componente Principal 1')
plt.ylabel('Componente Principal 2')
plt.colorbar(label='Cluster')
plt.grid(True)
plt.show()

"""## 25. Regressão polinomial vs linear.
Modele Global_active_power em função de Voltage.

Compare Regressão Linear Simples com Regressão Polinomial (grau 2).

Analise RMSE e a curva ajustada.

"""

from sklearn.model_selection import train_test_split
import pandas as pd
import numpy as np
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import PolynomialFeatures
from sklearn.metrics import mean_squared_error
import matplotlib.pyplot as plt
import seaborn as sns


# Assumindo que o DataFrame 'df' já está carregado e limpo como nos passos anteriores

# Selecione as features e o target
X = df[['Voltage']]
y = df['Global_active_power']

# Divida os dados em conjuntos de treino e teste
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

print("Shape dos dados de treino:")
print(X_train.shape, y_train.shape)
print("\nShape dos dados de teste:")
print(X_test.shape, y_test.shape)

# Treinar o modelo de Regressão Linear
linear_model = LinearRegression()
linear_model.fit(X_train, y_train)

# Treinar o modelo de Regressão Polinomial (grau 2)
poly_features = PolynomialFeatures(degree=2)
X_train_poly = poly_features.fit_transform(X_train)
poly_model = LinearRegression()
poly_model.fit(X_train_poly, y_train)

print("Modelo Linear treinado.")
print("Modelo Polinomial treinado.")

# Fazer previsões
y_pred_linear = linear_model.predict(X_test)
X_test_poly = poly_features.transform(X_test)
y_pred_poly = poly_model.predict(X_test_poly)

print("Previsões feitas para ambos os modelos.")

# Evaluate models using RMSE
rmse_linear = np.sqrt(mean_squared_error(y_test, y_pred_linear))
rmse_poly = np.sqrt(mean_squared_error(y_test, y_pred_poly))

print(f"RMSE for Linear Regression: {rmse_linear:.2f}")
print(f"RMSE for Polynomial Regression (Degree 2): {rmse_poly:.2f}")

# Ordenar os dados de teste para plotar curvas suaves
X_test_sorted = np.sort(X_test, axis=0)
y_pred_linear_sorted = linear_model.predict(X_test_sorted)
X_test_poly_sorted = poly_features.transform(X_test_sorted)
y_pred_poly_sorted = poly_model.predict(y_pred_poly_sorted) # Changed from X_test_poly_sorted

plt.figure(figsize=(12, 8))
sns.scatterplot(x=X_test['Voltage'].values, y=y_test.values, alpha=0.5, label='Dados Originais') # Changed label to Portuguese
plt.plot(X_test_sorted.flatten(), y_pred_linear_sorted, color='red', linewidth=2, label='Regressão Linear') # Changed label to Portuguese
plt.plot(X_test_sorted.flatten(), y_pred_poly_sorted, color='green', linewidth=2, label='Regressão Polinomial (Grau 2)') # Changed label to Portuguese

plt.title('Regressão Linear vs Polinomial em Global_active_power vs Voltage') # Changed title to Portuguese
plt.xlabel('Voltage')
plt.ylabel('Global_active_power')
plt.legend()
plt.grid(True)
plt.show()

# Análise e Interpretação:

# Com base nos valores de RMSE calculados e na visualização:

# - Comparação de RMSE: Um RMSE menor indica um ajuste melhor. Compare os valores de RMSE para os modelos linear e polinomial. O modelo com o menor RMSE é geralmente considerado com melhor desempenho preditivo nos dados de teste.

# - Comparação Visual: Observe os gráficos. O modelo de regressão linear ajusta uma linha reta aos dados, enquanto o modelo de regressão polinomial ajusta uma curva. Veja qual linha/curva parece seguir a tendência geral dos pontos de dados mais de perto. A regressão polinomial de grau 2 pode capturar uma ligeira curvatura na relação entre 'Voltage' e 'Global_active_power', se ela existir.

# - Conclusão: Com base tanto no RMSE quanto na inspeção visual, determine qual modelo fornece um ajuste melhor para prever 'Global_active_power' a partir de 'Voltage' neste conjunto de dados.